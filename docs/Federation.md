# Federation Configuration API

## Formatter Dictionary
It is common in many co-simulations for there to be a large number of information exchanges between federates to be identical in nature. For example, you may have two federates, one controlling all the HVACs in a group of houses and one modeling the physics of all the HVACs. The federate modeling the physics might send things like indoor air temperature and operating state of the HVAC while the controller federates receive this information and send out setpoint controls. In this situation, CoSim Toolbox (CST) considers these are two data transfer groups that can be defined in a similar and extensible way. 

A key part of defining these groups is the use of what CST calls a "formatter dicitonary." Formatter dictionaries are used to define the data transfer between two federates in a way that is allows the API to create the full HELICS output and input configuration. The two elements of the dictionary are the source (`src`) and destination (`des`) of the data transfer.

### Dictionary Schema 

Example dictionary

```Python
    house_formatter = {"src": {"from_fed": "hvac_physics",
                     "keys": ["Fdr1_Houses_@@_hse_##/", ""],
                     "indices": [["A", 1, 501], ["B", 1, 501], ["C", 1, 501]]},
             "des": [{"to_fed": "hvac_controller",
                      "from_fed": "hvac_physics",
                      "keys": ["Fdr1_hvac_controllers_@@_hse_##/", ""],
                      "indices": [["A", 1, 501], ["B", 1, 501], ["C", 1, 501]]
                      }]}
```
- `src` - CST keyword used as the name of the dictionary holding information about the federate providing the data being exchanged
- `des` - CST keyword used as the name of the dictionary holding information about the federate receving the data being exchanged. Note that this is a list and it is possible for multiple destinations dictionaries to be specified for a single source.
- `from_fed` - CST keyword indicating the HELICS name of the federate that is providing the information. Must appear in both the `src` dictionary and any `des` dictionaries. The `src[from_fed]` and `des[from_fed]` must be identical (**TODO** _this should be renamed to `fed_name` and we need to work out why it is required in both the `src` and `des` dictionaries_) (**TODO** _HELICS inputs and subscriptions can be from multiple sources. This is not highly common but it is a something we would want to support eventually_)
- `to_fed` - CST keyword indicating the HELICS name of the federate that is receiving the information; only appears in the `des` dictionary (**TODO** _this should be renaned `fed_name`_)
- `keys` - list of two elemement that can include CST configuration wildcards (see below). (**TODO** _this should be updated to be a dictionary with keys `name` for the sending side and `key` for sub side. The second element should be named `info`_) (**TODO**  _`keys` be renamed to `name` for publications and `keys` for subscriptions_)
    - element 1 - HELICS key (name of publisher for pubs, source of data for subs). This must be followed by a "/".
    - element 2 - name of object inside model that will get the data. This ends up in the HELICS publication or subscription "info" field. The "info" field in HELICS is only used by federates and does not change the behavior of the HELICS federate itself.
- `indices` - CST keyword used to define any wildcard replacement values used to generate the unique names of the elements of the `keys` list

### CST Configuration Wildcard Tags
To support creation of unqiue HELICS publication names and subscription keys, CST provides a way of defining wildcard tags (specified in the `keys` strings) that can be replaced with values in a sequence (specified in the `indices` lists). This provides a means of generating the necessary naming information for both the sender (publisher) and receiver (subscriber) of the exchanged information to ensure the connection is correctly created in HELICS.

If a wildcard is used, it is used in the strings specified in the "keys" list. For example:

```json
    "keys": ["neighborhood1_@@_hse_##/", ""]
```

The CST API only supports a limited number of wildcard substitution patterns which are discribed in the following subsections.

(**TODO** _This needs to be more general; maybe use regular expressions?_)

The `indices` element in formatter dictionary is a list. Each element of the list is a list itself that specified the range of values that will be used to subsitute into the string in place of the wildcards ("##", "@@" and "@list@").

#### `##` - single numerical wildcard
Replaces the `##` string in the `keys` list of strings with the values generated by the `indices` list.

```json
    "keys": ["neighborhood1_hse_##/", ""]
    "indices": [[1, 21, false]]
```
(**TODO** _Need to update the "keys" string definition to not require the "/"_)

The elements of the `indices` list are

- element 1 - integer of the first numeric value to be substituted
- element 2 - integer of one more than the last numeric value to be substituted (**TODO** _This should be updated to just be the last numeric value_)
- element 3 - boolean indicating whether to not use the name of specified in the `add_group()` API as the suffix of the publication name

(**TODO** _This needs to be changed to at least be an option in the "add\_group()" API rather than specified here. It likely also need to be inverted so that True indicates it gets appended and "False" indicates it does not._)

Note that it is possible for `indices` to contain multiple lists that are used in succession. For example

```json
    "keys": ["neighborhood1_hse_##/", ""]
    "indices": [[1, 21, false], [30, 41, false]]
```

This will create the following list of strings:
```
neighborhood1_hse_1
neighborhood1_hse_2
neighborhood1_hse_3
...
neighborhood1_hse_20
neighborhood1_hse_30
neighborhood1_hse_31
...
neighborhood1_hse_40
```


#### `@@` - string wildcard
Replaces the `@@` string in the `keys` list of strings with the values in the `indices` list.

```json
    "keys": ["neighborhood1_hse_@@/", ""]
    "indices": [["inactive", false]]
```
produces 

```
neighborhood1_hse_inactive
```

The elements of the `indices` list are

- element 1 - string used as a replacement for the `@@` wildcard
- element 2 - boolean indicating whether to not use the name of specified in the `add_group()` API as the suffix of the publication name


#### `@list@` - list-based wildcard
Replaces the `@list@` string in the `keys` list of strings with the strings in the `indices` list.

```json
    "keys": ["neighborhood1_hse_@@/", ""]
    "indices": ["1924", "1926", "1927", "1930", "1934"]
```

produces

```
neighborhood1_hse_1924
neighborhood1_hse_1926
neighborhood1_hse_1927
neighborhood1_hse_1930
neighborhood1_hse_1934
```

## Building a federation
The CST formatters are the building blocks of defining the data exchanges factilitated by HELICS. The formaters are used as part of the HELICS API to build the configuration information for the federation. 

To do this, a federation object needs to be created

```
federation = FederationConfig(<scenario name>, <schema name>, <federation name>, docker_flag)
```

(**TODO** - _Reverse order of FederationConfig parameters so we go from most abstract to most specific: analysis name, scenario name, federation name, docker flag_)\

(**TODO** - _Federations need to be able to support mixed runtime environments where some use a docker and some use a shell/bath script. Maybe move the docker flag down to the `add federate config()` API?_)

(**TODO** - _Need to update "schema name" to "analysis name"._)

The analysis name and scenario name are used for CST's time-series and metadata management systems and are using to set up these systems in preparation for the analysis and, in the case the of metadata system, eventually load the configuration information into the metadata.


### Adding federate configs
For each federate, a `FederateConfig` object needs to be created; the example below shows the simplest way of doing this for a federate named "federate1".

```Python
federate1_config = FederateConfig("federate1")
```

The federate configuration that is defined here is, generally, everything HELICS-related that is unrelated to the data exchanges; these will be defined separately. HELICS has defaults for almost every parameter it requires with the name of the federate being the big exception and thus it is the only required parameter in this API. Other common configuration parameters:

- `period` - The lowest resolution timestep this federate can use. The default value is one second.
- `uninterruptible` - Prevents the federate from being granted any other time except for the one it requests
- `terminate_on_error` - Terminates this federate if any other federate experiences a terminal error.
- `log_level` - Defines the criticality of messages that are logged
- `broker_address` - Defaults to local machine but can be set to the IP address of another machine if the federation is distributed.

There are many, many other configuration options; the [comprehensive documentation can be found here](https://docs.helics.org/en/latest/references/configuration_options_reference.html) but you'll probably need an understanding of the basics of HELICS to make sense of all the options; you can find the [user tutorial here](https://docs.helics.org/en/latest/user-guide/helics_user_tutorial.html).

The federate configuration options can be passed in a few different ways (like all Python `**kwargs`). In all cases, the names of the configuration options are the literal names defined in HELICS. The options can be included as names in the call to create the FederateConfig object:

```python
    federate1_config = FederateConfig("federate1", period=10, uninterruptible=False, terminate_on_error=True)
```

Alternatively, the configs can be passed in as a pre-defined dictionary:

```python
    federate1_configs_dict = {
        "period": 10,
        "uninterruptible": False,
        "terminate_on_error": True
    }
    federate1_config = FederateConfig("federate1", **federate1_configs_dict)
```



Once the federation object is defined, the configuration information for individual federates is added to the federation object through

```python
    federate_1 = federation.add_federate_config(<FederateConfig object>)
```

Once the configuration for each federate has been defined, it can be added to the federation object

``` python
    federate1 = federation.add_federate_config(federate1_config)
    federate2 = federation.add_federate_config(federate2_config)
    ...
```


### Adding data transfer definitions
Now for the data exchanges. These have been previously defined through the use of formatter dictionaries and can be added to the federation with a dedicated API. For example, using the previously defined `house` formatter dictionary, its possible to add a one-way data transfer using that formatter for a property from the "house_physics" federate of "indoor_air_temperature".

```python
    federation.add_group("indoor_air_temperature", "double", house_formatter)
```

The first parameter is the name of the output that will be used to create a unqiue identifier in HELICS. The second property is the data type and the third formatter being used. The `add_group()` API creates the definitions of the HELICS publication and subscription configurations and adds them to the appropriate federate definitions.
It's also possible to pass in a `**kwargs` dictionary with additional HELICS-specific publication and subscription configurations; again, see the [comprehensive documentation](https://docs.helics.org/en/latest/references/configuration_options_reference.html) on these options to see what configurations can be made.

(**TODO** - _The `**kwargs` need to be able to be unique for the pub side and the sub side. Do we do a `**sub_kwargs` and a `**pub_kwargs`?_)


(**TODO** - _Where is this expanded defintions stored? How can I see what was done and understand it?_)

As a reminder, this single API call only defines the data transfer one way. To complete the control loop in our example, you would also need do someething like the following.

```python
    hvac_setpoint_formatter = {"src": {"from_fed": "hvac_controller",
                     "keys": ["Fdr1_hvac_controllers_@@_hse_##", ""],
                     "indices": [["A", 1, 501], ["B", 1, 501], ["C", 1, 501]]},
             "des": [{"to_fed": "hvac_physics",
                      "from_fed": "hvac_controller",
                      "keys": ["Fdr1_Houses_@@_hse_##/", ""],
                      "indices": [["A", 1, 501], ["B", 1, 501], ["C", 1, 501]]
                      }]}

    federation.add_group("hvac_setpoint", "double", hvac_setpoint_formatter)
```

The use of formatters can be extended or modified to meet various data transfer topologies.

#### One publishing federate, many subscribing federates
To set up a data transfer configuration with one publisher and many subscribers, simply add additional dictionaries as described above to the `des` list in the formatter dictionary. It may be convenient to use a Python `for` loop to accomplish this.

Note that the formatter allows you to define any number of one-way data transfers to flow between the federates defined in the formatter dictionary.

#### Many publishing federates, one subscribing federate
As compared to the "one publication, many subscriber" topology, a little more hands-on work is needed. Through the use of a Python `for` loop you can modify the `src` and `des` dictionaries before calling the `add_group()` API. For example

```python
    for pub_fed in pub_fed_list:
        formatter["src"]["from_fed"] = pub_fed
        formatter["des"]["from_fed"] = pub_fed
        federation.add_group("data_name", "data_type", formatter)
```

## Checking the configuration
To help double-check that the formatters are working as expected, CST provides two APIs for checking the comprehensive list of publications and subscriptions. In looking through the publications and subscriptions defined in the federation object, the API looks for publications that are matched to subscriptions where the names of each do not perfectly match and may be an improperly match between the given publication and subscription. The APIs also look publications and subscriptions that are referenced but don't have a corresponding subscription or publication defined.

```python
    federation.check_pubs()
    federation.check_subs()
```


## Producing the data transfer configuration artifacts
Once all the data transfers between federates is defined through the use of the `add_groups()` API, the configuration artifacts themselves are produced. Depending on how the data configuration is being stored for later use by CST, the artifacts may be dictionaries that are written to the metadata database or JSON files that are written out to disk.

In either case, the `define_io()` API is called by the federation object to generate these artifacts.

```python
    federation.define_io()
```




