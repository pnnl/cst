"""
Created on 12/14/2023

Federate class that defines the basic operations of federates in Copper.

@author: Trevor Hardy
trevor.hardy@pnnl.gov
"""

import helics as h
import logging
import metadataDB

logger = logging.getLogger(__name__)
logger.addHandler(logging.StreamHandler())
logger.setLevel(logging.ERROR)

class Federate():
    """
    """

    def __init__(self):
        self.hfed = None
        self.mddb = None
        self.max_sim_time = -1
        self.period
        self.next_requested_time
        self.granted_time
        self.data_from_federation
        self.data_to_federation

        # Initialize the structure of the interface dictionaries
        self.data_from_federation["inputs"] = {}
        self.data_from_federation["endpoints"] = {}
        self.data_to_federation["publications"] = {}
        self.data_to_federation["endpoints"] = {}

    def populate_helics_input_data(self):
        """
        Updates the helics_input_data dictionary with the latest values from
        the federation. This is a a convenience that makes it easier for users
        of this class to be 
        """

    def connect_to_metadataDB(self):
        """
        The metadata database (metadataDB) contains the HELICS configuration
        JSON along with other pieces of useful configuration or federation
        management data. This method connects to that database and makes it 
        available for other methods in this class.
        """
        pass

    def initialize_fed(self):
        """
        """
        pass

    def create_helics_fed(self):
        """
        Using the HELICS configuration document from the metadataDB, this
        method creates the HELICS federate.
        """

        pass

    def create_federate(self):
        """
        """
        self.initialize_fed()
        self.create_helics_fed()

    def calculate_next_requested_time(self):
        """
        Many federates run at very regular time steps and thus the calculation
        of the requested time is trivial. In some cases, though, the requested
        time may be more dynamic and this method provides a place for users
        to overload the default calculation method if they need something 
        more complex.
        """
        self.next_requested_time = self.granted_time + self.period

    def generic_request_time(self, requested_time:float):
        """
        HELICS provides a variety of means of requesting time. The most common
        is a simple hfed.request_time(float) which is a blocking call. There
        are others that make the time request but allow users to continue
        working on something else while they wait for HELICS to get back to
        them with the granted time. This method is here just to allow users
        to sub-class and overload the Federate class and re-implement how
        they want to do time-requests.
        """
        self.granted_time = self.hfed.request_time(requested_time)
        pass

    def run_cosim_loop(self):
        """
        """
        self.hfed.enter_initializing_mode()
        self.hfed.enter_executing_mode()
        while self.granted_time < self.max_sim_time:
            self.calculate_next_requested_time()
            self.simulate_next_step()


    def get_data_from_federation(self):
        """
        This method is an automated way of getting data the rest of the 
        federation has sent out. 

        Directly accessing the value and message interfaces via the HELICS
        federate (hfed object) provides a much richer set of metadata 
        associate with these interfaces.
        """
        # Subscriptions and inputs
        for idx in range(0, self.hfed.n_inputs):
            input = self.hfed.get_subscription_by_index(idx)
            if input.name[0:7] == "_input_":
                # The name is auto-generated by HELICS and is a subscription
                self.data_from_federation["inputs"][input.target] = input.value
            else:
                self.data_from_federation["inputs"][input.name] = input.value
        
        # Endpoints
        for idx in range(0, self.hfed.n_endpoints):
            ep = self.hfed.get_endpoint_by_index
            # Delete out old message list to avoid confusion about when the message came in
            self.data_from_federation[ep.name] = []
            for message in range(0, ep.n_pending_messages):
                self.data_from_federation["endpoints"][ep.name].append(ep.get_message())

    def update_internal_model(self):
        """
        This is entirely user-defined code and is intended to be defined by
        sub-classing and overloading.
        """
        # Doing something silly for testing purposes

    def send_data_to_federation(self, pub_data):
        """
        This method provides an an easy way for users to send out any data
        to the rest of the federation. Users pass in a dict structured the same
        as the "data_from_federation" with sub-dicts for publications and 
        endpoints and keys inside those dicts for the name of the pub or
        endpoint. The value for the keys is slightly different, though:
            - pubs: value is the data to send
            - endpoints: value is a dictionary as follows
                {
                    "destination": <target endpoint name, may be an empty string>
                    "payload": <data to send>
                }

        Since endpoints can send multiple messages, each message needs its
        own entry in the pub_data 
        """

        # Publications
        for key, value in pub_data["publications"].items():
            pub = self.hfed.get_publication_by_name(key)
            pub.publish(value)

        # Endpoints
        for key, value in pub_data["endpoints"].items():
            ep = self.hfed.get_endpoint_by_name(key)
            if value["destination"] == "":
                ep.send_data(value["payload"])
            else: 
                ep.send_data(value["payload"], value["destination"])

    def simulate_next_step(self):
        """
        This method is the core of the main co-simulation loop where the time 
        request is made and once granted, data from the rest of the federation
        is collected and used to update the federate's internal model before
        sending out new data for the rest of the federation to use.
        """
        self.generic_request_time(self.next_requested_time)
        self.get_data_from_federation()
        self.update_internal_model()
        self.send_data_to_federation(self.pub_data)

    def destroy_federate(self):
        """
        As part of ending a HELICS co-simulation it is good housekeeping to
        formally destroy a federate. Doing so informs the rest of the
        federation that it is no longer a part of the co-simulation and they
        should proceed without it (if applicable). Generally this is done
        when the co-simulation is complete and all federates end execution
        at more or less the same wall-clock time.

        """
        logger.debug(f'{h.helicsFederateGetName(self.fed)} being destroyed, max time = {h.HELICS_TIME_MAXTIME}')
        requested_time = int(h.HELICS_TIME_MAXTIME)
        h.helicsFederateClearMessages(self.hfed)
        granted_time = h.helicsFederateRequestTime(self.fed, requested_time)
        logger.info(f'{h.helicsFederateGetName(self.fed)} granted time {granted_time}')
        h.helicsFederateDisconnect(self.hfed)
        h.helicsFederateFree(self.hfed)
        # h.helicsCloseLibrary()
        logger.debug(f'Federate {h.helicsFederateGetName(self.hfed)} finalized')


if __name__ == "__main__":
    test_fed = Federate()
    test_fed.connect_to_metadataDB()
    test_fed.create_federate()
    test_fed.run_cosim_loop()
    test_fed.destroy_federate()